#pragma once

#include "load_ini.h"

#define strcasecmp _stricmp 

void load_cfg(G_CONFIG* cfg)
{
    cfg->bit = 16;
    cfg->used_bit = 10;
    cfg->order = LITTLE_ENDIAN;
    cfg->pattern = BGGR;
    cfg->width = 1440;
    cfg->height = 1048;

    cfg->rgb_bit = 16;
    cfg->yuv_bit = 16;

    cfg->ob_on = 1;
    cfg->lsc_on = 1;
    cfg->gic_on = 1;
    cfg->isp_gain_on = 0;
    cfg->awb_on = 1;
    cfg->ltm_on = 0;
    cfg->ccm_on = 1;
    cfg->rgbgamma_on = 1;
    cfg->defog_on = 0;
    //cfg->ygamma_on = 0;
    cfg->sharp_on = 0;
    cfg->ynr_on = 1;
    cfg->cnr_on = 1;
    cfg->yuv_txi_on = 1;

    //12->16bit
    cfg->ob = 64 * 16;


    cfg->lsc_type = 0; //0为插值
    cfg->lsc_wblock = 17;
    cfg->lsc_hblock = 17;
    cfg->luma_str = 0.0;
    cfg->lsc_max_gain = 4096;
    cfg->lsc_gic_on = 1;
#if 1
    U16 lsc_tmpr[] = {
1363, 1339, 1294, 1297, 1292, 1254, 1238, 1229, 1254, 1221, 1240, 1254, 1269, 1296, 1331, 1336, 1371, 1346, 1298, 1285, 1224, 1215, 1219, 1205, 1192, 1184, 1203, 1194, 1229, 1236, 1274, 1307, 1324, 1339, 1346, 1313, 1269, 1227, 1204, 1186, 1175, 1169, 1135, 1157, 1161, 1191, 1202, 1245, 1256, 1296, 1341, 1346, 1309, 1253, 1220, 1179, 1154, 1127, 1118, 1131, 1106, 1138, 1144, 1192, 1215, 1248, 1265, 1347, 1341, 1303, 1255, 1193, 1166, 1137, 1110, 1107, 1093, 1111, 1106, 1151, 1166, 1184, 1220, 1277, 1338, 1355, 1289, 1229, 1154, 1135, 1114, 1085, 1112, 1065, 1104, 1096, 1125, 1130, 1151, 1213, 1267, 1298, 1338, 1286, 1239, 1172, 1122, 1093, 1078, 1064, 1060, 1065, 1114, 1108, 1130, 1167, 1222, 1257, 1294, 1335, 1282, 1223, 1165, 1116, 1094, 1058, 1052, 1026, 1032, 1072, 1100, 1120, 1146, 1201, 1252, 1290, 1353, 1294, 1203, 1160, 1112, 1075, 1045, 1028, 1052, 1035, 1061, 1081, 1108, 1151, 1194, 1246, 1300, 1319, 1297, 1214, 1150, 1119, 1084, 1052, 1048, 1034, 1045, 1051, 1078, 1097, 1137, 1202, 1244, 1277, 1337, 1291, 1220, 1150, 1132, 1073, 1049, 1045, 1024, 1044, 1055, 1089, 1103, 1138, 1193, 1249, 1299, 1331, 1290, 1226, 1167, 1117, 1099, 1070, 1049, 1036, 1041, 1079, 1091, 1120, 1172, 1206, 1248, 1278, 1345, 1286, 1256, 1180, 1146, 1102, 1099, 1061, 1067, 1072, 1103, 1097, 1136, 1185, 1198, 1232, 1300, 1320, 1314, 1240, 1182, 1150, 1137, 1114, 1108, 1090, 1089, 1108, 1114, 1156, 1180, 1224, 1255, 1291, 1350, 1315, 1247, 1201, 1169, 1157, 1124, 1120, 1116, 1117, 1134, 1127, 1156, 1196, 1234, 1276, 1295, 1748, 1322, 1293, 1230, 1194, 1183, 1165, 1151, 1137, 1147, 1151, 1162, 1188, 1221, 1257, 1294, 1314, 1605, 1357, 1271, 1272, 1224, 1217, 1208, 1195, 1194, 1176, 1196, 1201, 1224, 1271, 1274, 1270, 1275
    };
    U16 lsc_tmpgr[] = {
1456, 1430, 1471, 1419, 1389, 1355, 1361, 1364, 1377, 1338, 1361, 1405, 1355, 1412, 1399, 1447, 1477, 1468, 1450, 1384, 1386, 1330, 1292, 1297, 1305, 1316, 1303, 1304, 1324, 1319, 1384, 1393, 1467, 1463, 1455, 1437, 1391, 1351, 1298, 1284, 1249, 1234, 1241, 1228, 1256, 1265, 1302, 1318, 1364, 1405, 1411, 1491, 1436, 1359, 1277, 1239, 1202, 1194, 1182, 1172, 1190, 1198, 1222, 1239, 1279, 1328, 1362, 1384, 1480, 1388, 1353, 1271, 1219, 1184, 1161, 1140, 1119, 1130, 1146, 1156, 1184, 1223, 1283, 1346, 1387, 1485, 1416, 1322, 1252, 1198, 1125, 1123, 1091, 1077, 1074, 1123, 1132, 1171, 1229, 1273, 1353, 1406, 1431, 1363, 1316, 1230, 1169, 1117, 1106, 1071, 1065, 1059, 1102, 1113, 1161, 1200, 1256, 1331, 1371, 1446, 1369, 1302, 1217, 1147, 1116, 1072, 1048, 1031, 1041, 1047, 1096, 1123, 1186, 1267, 1327, 1413, 1438, 1374, 1287, 1206, 1149, 1094, 1057, 1041, 1038, 1036, 1064, 1084, 1119, 1182, 1243, 1302, 1388, 1467, 1382, 1281, 1235, 1138, 1098, 1046, 1030, 1024, 1024, 1034, 1093, 1120, 1165, 1232, 1283, 1362, 1454, 1390, 1317, 1237, 1153, 1098, 1058, 1052, 1032, 1049, 1053, 1114, 1138, 1198, 1242, 1287, 1369, 1437, 1379, 1315, 1229, 1173, 1139, 1080, 1073, 1073, 1077, 1085, 1132, 1151, 1216, 1279, 1325, 1382, 1475, 1405, 1362, 1267, 1203, 1154, 1128, 1104, 1094, 1121, 1101, 1137, 1195, 1242, 1281, 1327, 1395, 1456, 1432, 1346, 1302, 1228, 1211, 1185, 1140, 1143, 1161, 1168, 1164, 1213, 1257, 1295, 1356, 1405, 1458, 1420, 1372, 1342, 1285, 1249, 1223, 1199, 1211, 1199, 1237, 1242, 1257, 1300, 1330, 1376, 1428, 1978, 1464, 1404, 1380, 1336, 1287, 1306, 1278, 1236, 1273, 1281, 1270, 1293, 1340, 1361, 1392, 1438, 1819, 1486, 1420, 1412, 1395, 1363, 1329, 1366, 1361, 1359, 1357, 1349, 1373, 1354, 1404, 1428, 1452
    };
    U16 lsc_tmpgb[] = {
1563, 1480, 1443, 1415, 1361, 1334, 1314, 1301, 1307, 1293, 1272, 1303, 1360, 1432, 1409, 1467, 1502, 1551, 1502, 1436, 1375, 1351, 1270, 1276, 1267, 1238, 1236, 1257, 1287, 1277, 1349, 1398, 1459, 1486, 1570, 1494, 1408, 1352, 1291, 1266, 1205, 1211, 1202, 1202, 1217, 1241, 1272, 1326, 1371, 1433, 1474, 1552, 1524, 1426, 1358, 1281, 1205, 1142, 1134, 1136, 1179, 1135, 1227, 1237, 1280, 1353, 1426, 1489, 1606, 1490, 1449, 1322, 1245, 1191, 1141, 1128, 1091, 1111, 1141, 1165, 1205, 1257, 1310, 1413, 1510, 1602, 1507, 1410, 1334, 1236, 1149, 1114, 1102, 1062, 1100, 1125, 1136, 1182, 1259, 1333, 1433, 1479, 1610, 1520, 1401, 1309, 1205, 1161, 1106, 1068, 1054, 1071, 1069, 1125, 1187, 1272, 1372, 1416, 1516, 1598, 1517, 1409, 1294, 1205, 1149, 1080, 1049, 1041, 1043, 1061, 1137, 1170, 1245, 1345, 1434, 1521, 1607, 1525, 1420, 1302, 1193, 1142, 1069, 1042, 1035, 1042, 1046, 1101, 1161, 1233, 1347, 1410, 1484, 1628, 1512, 1413, 1295, 1182, 1116, 1067, 1060, 1030, 1024, 1055, 1103, 1167, 1227, 1340, 1402, 1492, 1575, 1509, 1416, 1306, 1214, 1122, 1095, 1073, 1045, 1047, 1060, 1090, 1146, 1219, 1344, 1455, 1459, 1548, 1488, 1398, 1296, 1224, 1153, 1076, 1066, 1057, 1053, 1087, 1125, 1177, 1254, 1330, 1416, 1477, 1578, 1497, 1414, 1294, 1238, 1178, 1121, 1102, 1081, 1085, 1106, 1154, 1172, 1265, 1324, 1399, 1455, 1588, 1490, 1405, 1334, 1257, 1207, 1138, 1119, 1108, 1141, 1148, 1170, 1189, 1301, 1355, 1393, 1495, 1562, 1481, 1418, 1344, 1264, 1222, 1195, 1166, 1160, 1176, 1192, 1209, 1225, 1285, 1331, 1422, 1489, 1991, 1521, 1450, 1369, 1315, 1277, 1223, 1244, 1218, 1225, 1240, 1229, 1279, 1312, 1393, 1440, 1467, 1883, 1483, 1451, 1421, 1358, 1325, 1313, 1267, 1270, 1269, 1270, 1325, 1304, 1336, 1372, 1436, 1463
    };
    U16 lsc_tmpb[] = {
1136, 1124, 1124, 1115, 1084, 1094, 1108, 1109, 1085, 1074, 1095, 1097, 1094, 1103, 1105, 1147, 1171, 1139, 1172, 1104, 1093, 1094, 1089, 1110, 1096, 1110, 1106, 1099, 1106, 1061, 1095, 1120, 1115, 1155, 1155, 1133, 1141, 1097, 1098, 1100, 1110, 1095, 1132, 1098, 1090, 1119, 1088, 1091, 1117, 1163, 1153, 1183, 1180, 1129, 1084, 1131, 1092, 1083, 1110, 1119, 1116, 1089, 1117, 1119, 1079, 1124, 1127, 1136, 1162, 1181, 1100, 1108, 1095, 1083, 1121, 1103, 1144, 1149, 1114, 1106, 1088, 1093, 1113, 1128, 1153, 1179, 1142, 1086, 1107, 1081, 1102, 1128, 1154, 1105, 1110, 1117, 1115, 1092, 1086, 1108, 1121, 1147, 1176, 1157, 1093, 1110, 1091, 1104, 1128, 1149, 1137, 1118, 1131, 1105, 1093, 1081, 1095, 1104, 1104, 1158, 1179, 1123, 1086, 1107, 1134, 1084, 1095, 1127, 1097, 1121, 1115, 1080, 1077, 1100, 1114, 1136, 1155, 1175, 1090, 1092, 1069, 1093, 1081, 1111, 1136, 1108, 1107, 1110, 1096, 1081, 1093, 1075, 1113, 1156, 1127, 1098, 1066, 1050, 1074, 1089, 1109, 1082, 1113, 1108, 1107, 1091, 1080, 1063, 1085, 1131, 1219, 1130, 1098, 1069, 1089, 1070, 1073, 1097, 1116, 1085, 1099, 1083, 1081, 1101, 1075, 1093, 1101, 1146, 1122, 1099, 1104, 1093, 1084, 1097, 1101, 1104, 1070, 1083, 1094, 1069, 1052, 1058, 1102, 1115, 1169, 1144, 1104, 1082, 1054, 1056, 1072, 1085, 1079, 1070, 1060, 1039, 1057, 1057, 1090, 1081, 1118, 1150, 1127, 1093, 1078, 1036, 1036, 1081, 1040, 1069, 1083, 1074, 1037, 1036, 1055, 1082, 1097, 1104, 1131, 1124, 1073, 1067, 1072, 1024, 1050, 1032, 1048, 1060, 1054, 1062, 1034, 1076, 1105, 1077, 1133, 1519, 1124, 1104, 1097, 1070, 1067, 1043, 1045, 1056, 1054, 1070, 1038, 1047, 1091, 1071, 1112, 1112, 1358, 1123, 1125, 1078, 1060, 1098, 1054, 1091, 1046, 1082, 1099, 1096, 1087, 1063, 1055, 1118, 1127
    };
#endif

    cfg->isp_gain = 1024 * 0.8;

    cfg->gic_str = 0.8;
    cfg->gic_thd = 1.25;
     
    cfg->r_gain = 1024 * 3.09;
    cfg->g_gain = 1024 * 1;
    cfg->b_gain = 1024 * 1.45;


    cfg->ltm_r = 20;
    cfg->ltm_str = 1.3;
    cfg->ltm_gain_limit_max = 2;
    cfg->ltm_gain_limit_min = 0.0;


    float ccm_tmp[9] = {
0.24,1.6,-0.9,
0.26,-0.3,1.1,
0.5,-0.3,0.78

    };




    cfg->defog_smp_ratio = 4;
    cfg->light_ratio = 1.0;
    cfg->defog_str = 0.15;

    U32 gamma_xtmp[GAMMA_LENGTH] =
    {
        0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,256,320,384,448,512,640,768,896,1024,1280,1536,1792,2048,2304,2560,2816,3072,3328,3584,3840,4095
    };

    U32 gamma_ytmp[GAMMA_LENGTH] =
    {
        0,6,11,17,22,28,33,39,44,55,66,77,88,109,130,150,170,210,248,286,323,393,460,525,586,702,809,909,1002,1172,1323,1461,1587,1810,2003,2173,2325,2589,2812,3010,3191,3355,3499,3624,3736,3836,3927,4012,4095
    };

    cfg->ynr_r = 1;
    cfg->cnr_r = 3;

    cfg->txi_r_detail = 1;
    cfg->txi_r_bifilter = 1;
    cfg->txi_str = 20;



    //以下后处理
    U16 lsc_blk = cfg->lsc_wblock * cfg->lsc_hblock;
    cfg->lsc_rgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_bgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_grgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_gbgain = (U16*)malloc(sizeof(U16) * lsc_blk);

    memcpy(cfg->lsc_rgain, lsc_tmpr, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_bgain, lsc_tmpb, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_grgain, lsc_tmpgr, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_gbgain, lsc_tmpgb, sizeof(U16) * lsc_blk);

    if (cfg->awb_on == 0)
    {
        cfg->r_gain = 1024;
        cfg->g_gain = 1024;
        cfg->b_gain = 1024;
    }
    if (cfg->ccm_on == 1)
    {
        memcpy(cfg->ccm, ccm_tmp, 9 * sizeof(float));
    }
    else 
    {
        // 如果不启用CCM，则设置为单位矩阵
        cfg->ccm[0] = 1.0f; cfg->ccm[1] = 0.0f; cfg->ccm[2] = 0.0f;
        cfg->ccm[3] = 0.0f; cfg->ccm[4] = 1.0f; cfg->ccm[5] = 0.0f;
        cfg->ccm[6] = 0.0f; cfg->ccm[7] = 0.0f; cfg->ccm[8] = 1.0f;
    }
    calc_NAI((float)cfg->r_gain / 1024, (float)cfg->g_gain / 1024,
        (float)cfg->b_gain / 1024, cfg->ccm);
   
    if (cfg->rgb_bit > 12)
    {
        U8 shift = cfg->rgb_bit - 12;
        for (int i = 0; i < GAMMA_LENGTH; i++)
        {
            cfg->gamma_x[i] = gamma_xtmp[i] << shift;
            cfg->gamma_y[i] = gamma_ytmp[i] << shift;
        }
    }
    else if (cfg->rgb_bit < 12)
    {
        U8 shift = 12 - cfg->rgb_bit;
        for (int i = 0; i < GAMMA_LENGTH; i++)
        {
            cfg->gamma_x[i] = gamma_xtmp[i] >> shift;
            cfg->gamma_y[i] = gamma_ytmp[i] >> shift;
        }
    }

    return;
}

void calc_NAI(float rg, float gg, float bg, float* ccm)
{
    float nai[3] = { 0 };

  

    // 增益平方
    float gains[3] = {
        rg * rg,
        gg * gg,
        bg * bg
    };

    // 计算每个输出通道的NAI
    for (int out_c = 0; out_c < 3; ++out_c) {
        for (int in_c = 0; in_c < 3; ++in_c) {
            float coeff = ccm[out_c * 3 + in_c];  // 行主序访问
            nai[out_c] += coeff * coeff * gains[in_c];
        }
    }

    LOG("NAI = [%.2f, %.2f, %.2f]\n", nai[0], nai[1], nai[2]);
}

// 从 INI 文件加载配置
void load_cfg_from_ini(const char* filename, G_CONFIG* cfg) {
    FILE* f = fopen(filename, "r");
    if (!f) {
        perror("fopen");
        return;
    }
    // 初始化默认值
    memset(cfg, 0, sizeof(*cfg));
    cfg->order = LITTLE_ENDIAN;
    cfg->pattern = BGGR;
    cfg->lsc_rgain = NULL;

    char line[256], section[64] = { 0 };
    while (fgets(line, sizeof(line), f)) {
        char* p = trim(line);
        if (*p == 0 || *p == ';') continue;
        if (*p == '[') {
            char* end = strchr(p, ']');
            if (end) {
                size_t len = end - p - 1;
                strncpy(section, p + 1, len);
                section[len] = '\0';
            }
            continue;
        }
        char* eq = strchr(p, '=');
        if (!eq) continue;
        *eq = '\0';
        char* key = trim(p), * val = trim(eq + 1);

        if (strcmp(section, "raw_param") == 0) {
            if (strcmp(key, "bit") == 0) cfg->bit = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "used_bit") == 0) cfg->used_bit = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "order") == 0) cfg->order = parse_order(val);
            else if (strcmp(key, "pattern") == 0) cfg->pattern = parse_pattern(val);
        }
        else if (strcmp(section, "module_on") == 0) {
            if (strcmp(key, "ob_on") == 0) cfg->ob_on = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "lsc_on") == 0) cfg->lsc_on = (U8)strtoul(val, NULL, 0);
        }
        else if (strcmp(section, "ob") == 0) {
            if (strcmp(key, "ob") == 0) cfg->ob = (U16)(eval_simple_expr(val) + 0.5);
        }
        else if (strcmp(section, "lsc") == 0) {
            if (strcmp(key, "lsc_rgain") == 0) parse_u16_array(val, &cfg->lsc_rgain);
        }
        else if (strcmp(section, "awb") == 0) {
            if (strcmp(key, "r_gain") == 0) cfg->r_gain = (U16)(eval_simple_expr(val) + 0.5);
        }
        else if (strcmp(section, "ccm") == 0) {
            if (strcmp(key, "ccm") == 0) parse_float_array9(val, cfg->ccm);
        }
    }
    fclose(f);
}

// 去除首尾空白
static char* trim(char* s) {
    char* end;
    while (isspace((unsigned char)*s)) s++;
    if (*s == 0) return s;
    end = s + strlen(s) - 1;
    while (end > s && isspace((unsigned char)*end)) end--;
    *(end + 1) = 0;
    return s;
}

// 解析字节顺序
static ByteOrder parse_order(const char* s) {
    return (strcasecmp(s, "BIG_ENDIAN") == 0) ? BIG_ENDIAN : LITTLE_ENDIAN;
}

// 解析 Bayer 格式
static BayerPattern parse_pattern(const char* s) {
    if (strcasecmp(s, "RGGB") == 0) return RGGB;
    else if (strcasecmp(s, "GRBG") == 0) return GRBG;
    else if (strcasecmp(s, "GBRG") == 0) return GBRG;
    else                                   return BGGR;
}

// 计算简单表达式：支持 a 或 a*b
static double eval_simple_expr(const char* s) {
    char* star = (char*)malloc(strlen(s) + 1);
    strcpy(star, s);
    if (!star) {
        return strtod(s, NULL);
    }
    else {
        double a = strtod(s, NULL);
        double b = strtod(star + 1, NULL);
        return a * b;
    }
}

// 解析 U16 数组，返回元素个数
static int parse_u16_array(const char* s, U16** out) {
    // 定位到 '[' 并跳过
    while (*s && *s != '[') s++;
    if (*s == '[') s++;
    size_t cap = 4, cnt = 0;
    U16* arr = (U16*)malloc(cap * sizeof(U16));
    char* copy = strdup(s);
    char* rb = strchr(copy, ']');
    if (rb) *rb = '\0';

    char* tok = strtok(copy, ",");
    while (tok) {
        double v = eval_simple_expr(trim(tok));
        if (cnt >= cap) {
            cap *= 2;
            arr = (U16*)realloc(arr, cap * sizeof(U16));
        }
        arr[cnt++] = (U16)(v + 0.5);
        tok = strtok(NULL, ",");
    }

    free(copy);
    *out = arr;
    return (int)cnt;
}

// 解析 9 元素 float 数组
static void parse_float_array9(const char* s, float out[9]) {
    while (*s && *s != '[') s++;
    if (*s == '[') s++;
    char* copy = strdup(s);
    char* rb = strchr(copy, ']');
    if (rb) *rb = '\0';

    int idx = 0;
    char* tok = strtok(copy, ",");
    while (tok && idx < 9) {
        out[idx++] = (float)eval_simple_expr(trim(tok));
        tok = strtok(NULL, ",");
    }

    free(copy);
}
