#pragma once

#include "load_ini.h"

#define strcasecmp _stricmp 

void load_cfg(G_CONFIG* cfg)
{
    cfg->bit = 16;
    cfg->used_bit = 10;
    cfg->order = LITTLE_ENDIAN;
    cfg->pattern = BGGR;
    cfg->width = 1440;
    cfg->height = 1048;

    cfg->rgb_bit = 16;
    cfg->yuv_bit = 16;

    cfg->ob_on = 1;
    cfg->lsc_on = 1;
    cfg->gic_on = 1;
    cfg->isp_gain_on = 0;
    cfg->awb_on = 1;
    cfg->ltm_on = 0;
    cfg->ccm_on = 1;
    cfg->rgbgamma_on = 1;
    cfg->defog_on = 0;
    //cfg->ygamma_on = 0;
    cfg->sharp_on = 0;
    cfg->ynr_on = 1;
    cfg->cnr_on = 1;
    cfg->yuv_txi_on = 1;

    //12->16bit
    cfg->ob = 64 * 16;


    cfg->lsc_type = 0; //0为插值
    cfg->lsc_wblock = 17;
    cfg->lsc_hblock = 17;
    cfg->luma_str = 0.0;
    cfg->lsc_max_gain = 4096;
    cfg->lsc_gic_on = 1;
#if 1
    U16 lsc_tmpr[] = {
1151, 1121, 1118, 1135, 1121, 1145, 1186, 1199, 1166, 1199, 1179, 1209, 1209, 1176, 1213, 1241, 1259, 1148, 1124, 1106, 1103, 1118, 1151, 1151, 1157, 1189, 1202, 1199, 1202, 1202, 1209, 1209, 1209, 1234, 1145, 1154, 1126, 1106, 1132, 1154, 1163, 1170, 1196, 1202, 1206, 1206, 1192, 1213, 1199, 1216, 1237, 1148, 1160, 1135, 1141, 1129, 1141, 1170, 1192, 1199, 1202, 1216, 1227, 1192, 1189, 1192, 1209, 1263, 1183, 1151, 1157, 1135, 1124, 1170, 1173, 1196, 1230, 1213, 1230, 1206, 1192, 1192, 1183, 1199, 1209, 1179, 1166, 1132, 1141, 1124, 1170, 1160, 1179, 1209, 1220, 1241, 1237, 1199, 1179, 1179, 1220, 1209, 1209, 1176, 1132, 1141, 1154, 1163, 1163, 1186, 1206, 1213, 1223, 1206, 1176, 1183, 1173, 1206, 1196, 1173, 1166, 1135, 1124, 1121, 1141, 1173, 1186, 1199, 1213, 1213, 1213, 1170, 1148, 1154, 1179, 1237, 1192, 1157, 1132, 1126, 1129, 1145, 1173, 1173, 1176, 1206, 1199, 1202, 1166, 1138, 1151, 1170, 1179, 1186, 1170, 1138, 1121, 1129, 1132, 1176, 1166, 1176, 1176, 1186, 1192, 1160, 1148, 1121, 1163, 1138, 1209, 1170, 1121, 1138, 1112, 1115, 1154, 1148, 1160, 1157, 1166, 1163, 1138, 1106, 1112, 1132, 1160, 1179, 1163, 1132, 1124, 1100, 1106, 1100, 1124, 1124, 1148, 1151, 1141, 1109, 1109, 1100, 1115, 1124, 1186, 1132, 1115, 1089, 1075, 1086, 1092, 1073, 1086, 1109, 1118, 1112, 1109, 1100, 1081, 1089, 1089, 1183, 1118, 1092, 1067, 1062, 1062, 1062, 1070, 1067, 1073, 1075, 1095, 1078, 1075, 1059, 1067, 1084, 1157, 1115, 1081, 1065, 1041, 1024, 1054, 1047, 1034, 1057, 1057, 1059, 1059, 1052, 1054, 1065, 1274, 1126, 1086, 1059, 1041, 1054, 1039, 1031, 1029, 1036, 1047, 1067, 1049, 1070, 1054, 1044, 1075, 1057, 1118, 1086, 1073, 1057, 1078, 1031, 1041, 1054, 1034, 1062, 1059, 1073, 1034, 1062, 1049, 1067, 1095
    };
    U16 lsc_tmpgr[] = {
1523, 1534, 1461, 1395, 1372, 1332, 1324, 1304, 1301, 1327, 1342, 1386, 1381, 1424, 1490, 1541, 1599, 1562, 1527, 1490, 1418, 1356, 1314, 1284, 1269, 1253, 1267, 1299, 1329, 1369, 1412, 1467, 1562, 1562, 1566, 1537, 1483, 1403, 1309, 1272, 1248, 1221, 1208, 1228, 1251, 1284, 1324, 1395, 1448, 1544, 1562, 1618, 1566, 1458, 1364, 1286, 1248, 1196, 1177, 1161, 1185, 1196, 1224, 1274, 1348, 1436, 1517, 1584, 1649, 1548, 1455, 1367, 1251, 1198, 1159, 1130, 1134, 1135, 1161, 1189, 1262, 1319, 1415, 1483, 1573, 1695, 1562, 1448, 1345, 1260, 1163, 1109, 1088, 1086, 1085, 1126, 1171, 1233, 1304, 1403, 1487, 1595, 1662, 1558, 1455, 1340, 1239, 1149, 1085, 1054, 1048, 1066, 1099, 1128, 1196, 1274, 1398, 1483, 1580, 1630, 1562, 1436, 1342, 1215, 1122, 1068, 1049, 1040, 1041, 1078, 1126, 1177, 1258, 1364, 1448, 1580, 1657, 1580, 1436, 1327, 1213, 1130, 1073, 1038, 1030, 1038, 1048, 1100, 1181, 1260, 1369, 1461, 1551, 1645, 1573, 1452, 1337, 1221, 1128, 1088, 1037, 1027, 1024, 1061, 1117, 1171, 1253, 1340, 1430, 1534, 1690, 1566, 1464, 1348, 1204, 1124, 1076, 1037, 1024, 1033, 1068, 1102, 1167, 1246, 1342, 1430, 1503, 1637, 1558, 1448, 1332, 1219, 1132, 1090, 1043, 1026, 1024, 1074, 1124, 1183, 1242, 1334, 1418, 1493, 1630, 1544, 1448, 1334, 1246, 1155, 1085, 1053, 1045, 1064, 1097, 1128, 1185, 1267, 1332, 1406, 1470, 1622, 1534, 1409, 1329, 1258, 1179, 1115, 1088, 1078, 1095, 1104, 1163, 1193, 1267, 1337, 1381, 1433, 1630, 1530, 1436, 1348, 1267, 1202, 1159, 1124, 1115, 1128, 1159, 1191, 1242, 1284, 1337, 1406, 1686, 1576, 1490, 1439, 1364, 1306, 1246, 1191, 1159, 1157, 1159, 1202, 1217, 1272, 1306, 1361, 1401, 1467, 1558, 1470, 1467, 1395, 1369, 1281, 1251, 1211, 1215, 1244, 1237, 1284, 1291, 1332, 1381, 1403, 1445
    };
    U16 lsc_tmpgb[] = {
1467, 1486, 1445, 1445, 1427, 1415, 1439, 1418, 1418, 1418, 1464, 1461, 1470, 1470, 1486, 1502, 1467, 1496, 1489, 1451, 1410, 1387, 1365, 1351, 1365, 1349, 1341, 1376, 1376, 1404, 1427, 1442, 1489, 1492, 1502, 1467, 1427, 1378, 1328, 1315, 1297, 1280, 1264, 1283, 1297, 1328, 1338, 1365, 1421, 1458, 1492, 1489, 1476, 1390, 1357, 1288, 1262, 1230, 1206, 1198, 1212, 1223, 1252, 1285, 1338, 1390, 1424, 1467, 1502, 1442, 1384, 1320, 1262, 1202, 1163, 1153, 1138, 1157, 1161, 1215, 1237, 1285, 1343, 1407, 1473, 1516, 1442, 1362, 1276, 1219, 1159, 1134, 1109, 1094, 1109, 1129, 1159, 1198, 1250, 1317, 1410, 1458, 1526, 1439, 1351, 1280, 1200, 1149, 1096, 1067, 1074, 1086, 1094, 1125, 1173, 1228, 1290, 1373, 1427, 1553, 1439, 1365, 1257, 1187, 1123, 1081, 1059, 1048, 1056, 1075, 1114, 1153, 1221, 1276, 1341, 1430, 1502, 1415, 1330, 1262, 1177, 1121, 1077, 1043, 1032, 1038, 1062, 1114, 1138, 1185, 1266, 1346, 1390, 1506, 1442, 1354, 1255, 1208, 1129, 1100, 1057, 1043, 1024, 1059, 1107, 1138, 1187, 1255, 1310, 1381, 1533, 1448, 1357, 1271, 1208, 1130, 1086, 1060, 1030, 1046, 1070, 1110, 1153, 1198, 1237, 1317, 1373, 1522, 1461, 1384, 1290, 1210, 1146, 1091, 1057, 1056, 1065, 1093, 1121, 1183, 1208, 1259, 1312, 1367, 1536, 1454, 1384, 1297, 1241, 1179, 1129, 1089, 1082, 1109, 1134, 1157, 1200, 1226, 1276, 1325, 1351, 1536, 1436, 1407, 1320, 1259, 1221, 1173, 1136, 1144, 1153, 1171, 1187, 1232, 1241, 1283, 1315, 1376, 1560, 1458, 1436, 1365, 1305, 1271, 1228, 1210, 1204, 1208, 1232, 1250, 1271, 1295, 1317, 1351, 1608, 1526, 1470, 1436, 1404, 1362, 1341, 1295, 1280, 1271, 1285, 1310, 1312, 1333, 1335, 1365, 1384, 1398, 1502, 1473, 1458, 1439, 1413, 1413, 1357, 1370, 1351, 1357, 1376, 1392, 1395, 1401, 1395, 1424, 1410
    };
    U16 lsc_tmpb[] = {
1319, 1290, 1280, 1214, 1227, 1214, 1230, 1195, 1202, 1205, 1227, 1266, 1249, 1280, 1323, 1330, 1338, 1323, 1273, 1269, 1223, 1214, 1175, 1189, 1178, 1172, 1198, 1211, 1236, 1249, 1259, 1305, 1327, 1338, 1305, 1297, 1256, 1230, 1202, 1189, 1169, 1172, 1149, 1180, 1180, 1205, 1227, 1256, 1297, 1323, 1338, 1342, 1297, 1256, 1211, 1180, 1163, 1154, 1135, 1135, 1157, 1169, 1172, 1208, 1227, 1253, 1297, 1361, 1330, 1308, 1239, 1202, 1160, 1140, 1127, 1103, 1121, 1138, 1143, 1157, 1195, 1189, 1246, 1305, 1330, 1334, 1290, 1243, 1183, 1163, 1108, 1093, 1088, 1093, 1103, 1127, 1149, 1163, 1183, 1217, 1273, 1316, 1357, 1301, 1249, 1183, 1140, 1101, 1088, 1066, 1066, 1083, 1111, 1130, 1149, 1166, 1205, 1253, 1312, 1361, 1308, 1243, 1186, 1124, 1090, 1068, 1080, 1073, 1068, 1111, 1095, 1124, 1157, 1195, 1236, 1305, 1330, 1276, 1230, 1163, 1098, 1098, 1075, 1051, 1058, 1058, 1088, 1093, 1119, 1135, 1183, 1246, 1273, 1385, 1312, 1236, 1180, 1116, 1095, 1071, 1040, 1054, 1038, 1071, 1090, 1121, 1138, 1160, 1214, 1263, 1353, 1308, 1253, 1166, 1140, 1080, 1068, 1042, 1044, 1058, 1073, 1093, 1106, 1127, 1169, 1192, 1236, 1338, 1283, 1227, 1189, 1135, 1095, 1051, 1044, 1038, 1035, 1071, 1085, 1111, 1135, 1154, 1195, 1246, 1369, 1297, 1227, 1183, 1143, 1090, 1063, 1024, 1038, 1066, 1080, 1095, 1127, 1121, 1172, 1198, 1217, 1357, 1283, 1227, 1175, 1132, 1106, 1063, 1051, 1056, 1068, 1073, 1095, 1108, 1135, 1152, 1195, 1236, 1349, 1301, 1256, 1172, 1140, 1114, 1085, 1066, 1066, 1068, 1098, 1111, 1132, 1138, 1169, 1189, 1402, 1323, 1273, 1239, 1202, 1166, 1149, 1101, 1090, 1093, 1103, 1106, 1127, 1160, 1157, 1175, 1214, 1227, 1323, 1290, 1256, 1211, 1175, 1166, 1111, 1116, 1114, 1140, 1149, 1152, 1186, 1180, 1183, 1220, 1259
    };
#endif

    cfg->isp_gain = 1024 * 0.8;

    cfg->gic_str = 0.8;
    cfg->gic_thd = 1.25;
     
    cfg->r_gain = 1024 * 1.24;
    cfg->g_gain = 1024 * 1; 
    cfg->b_gain = 1024 * 1.34;


    cfg->ltm_r = 20;
    cfg->ltm_str = 1.3;
    cfg->ltm_gain_limit_max = 2;
    cfg->ltm_gain_limit_min = 0.0;


    float ccm_tmp[9] = {
1.3,-0.4,0.25,
-0.14,0.7,0.39,
-0.15,0.69,0.36
    };

    cfg->defog_smp_ratio = 4;
    cfg->light_ratio = 1.0;
    cfg->defog_str = 0.15;

    U32 gamma_xtmp[GAMMA_LENGTH] =
    {
        0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,256,320,384,448,512,640,768,896,1024,1280,1536,1792,2048,2304,2560,2816,3072,3328,3584,3840,4095
    };

    U32 gamma_ytmp[GAMMA_LENGTH] =
    {
        0,6,11,17,22,28,33,39,44,55,66,77,88,109,130,150,170,210,248,286,323,393,460,525,586,702,809,909,1002,1172,1323,1461,1587,1810,2003,2173,2325,2589,2812,3010,3191,3355,3499,3624,3736,3836,3927,4012,4095
    };

    cfg->ynr_r = 1;
    cfg->cnr_r = 3;

    cfg->txi_r_detail = 1;
    cfg->txi_r_bifilter = 1;
    cfg->txi_str = 20;



    //以下后处理
    U16 lsc_blk = cfg->lsc_wblock * cfg->lsc_hblock;
    cfg->lsc_rgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_bgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_grgain = (U16*)malloc(sizeof(U16) * lsc_blk);
    cfg->lsc_gbgain = (U16*)malloc(sizeof(U16) * lsc_blk);

    memcpy(cfg->lsc_rgain, lsc_tmpr, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_bgain, lsc_tmpb, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_grgain, lsc_tmpgr, sizeof(U16) * lsc_blk);
    memcpy(cfg->lsc_gbgain, lsc_tmpgb, sizeof(U16) * lsc_blk);

    if (cfg->awb_on == 0)
    {
        cfg->r_gain = 1024;
        cfg->g_gain = 1024;
        cfg->b_gain = 1024;
    }
    if (cfg->ccm_on == 1)
    {
        memcpy(cfg->ccm, ccm_tmp, 9 * sizeof(float));
    }
    else 
    {
        // 如果不启用CCM，则设置为单位矩阵
        cfg->ccm[0] = 1.0f; cfg->ccm[1] = 0.0f; cfg->ccm[2] = 0.0f;
        cfg->ccm[3] = 0.0f; cfg->ccm[4] = 1.0f; cfg->ccm[5] = 0.0f;
        cfg->ccm[6] = 0.0f; cfg->ccm[7] = 0.0f; cfg->ccm[8] = 1.0f;
    }
    calc_NAI((float)cfg->r_gain / 1024, (float)cfg->g_gain / 1024,
        (float)cfg->b_gain / 1024, cfg->ccm);
   
    if (cfg->rgb_bit > 12)
    {
        U8 shift = cfg->rgb_bit - 12;
        for (int i = 0; i < GAMMA_LENGTH; i++)
        {
            cfg->gamma_x[i] = gamma_xtmp[i] << shift;
            cfg->gamma_y[i] = gamma_ytmp[i] << shift;
        }
    }
    else if (cfg->rgb_bit < 12)
    {
        U8 shift = 12 - cfg->rgb_bit;
        for (int i = 0; i < GAMMA_LENGTH; i++)
        {
            cfg->gamma_x[i] = gamma_xtmp[i] >> shift;
            cfg->gamma_y[i] = gamma_ytmp[i] >> shift;
        }
    }

    return;
}

void calc_NAI(float rg, float gg, float bg, float* ccm)
{
    float nai[3] = { 0 };

  

    // 增益平方
    float gains[3] = {
        rg * rg,
        gg * gg,
        bg * bg
    };

    // 计算每个输出通道的NAI
    for (int out_c = 0; out_c < 3; ++out_c) {
        for (int in_c = 0; in_c < 3; ++in_c) {
            float coeff = ccm[out_c * 3 + in_c];  // 行主序访问
            nai[out_c] += coeff * coeff * gains[in_c];
        }
    }

    LOG("NAI = [%.2f, %.2f, %.2f]\n", nai[0], nai[1], nai[2]);
}

// 从 INI 文件加载配置
void load_cfg_from_ini(const char* filename, G_CONFIG* cfg) {
    FILE* f = fopen(filename, "r");
    if (!f) {
        perror("fopen");
        return;
    }
    // 初始化默认值
    memset(cfg, 0, sizeof(*cfg));
    cfg->order = LITTLE_ENDIAN;
    cfg->pattern = BGGR;
    cfg->lsc_rgain = NULL;

    char line[256], section[64] = { 0 };
    while (fgets(line, sizeof(line), f)) {
        char* p = trim(line);
        if (*p == 0 || *p == ';') continue;
        if (*p == '[') {
            char* end = strchr(p, ']');
            if (end) {
                size_t len = end - p - 1;
                strncpy(section, p + 1, len);
                section[len] = '\0';
            }
            continue;
        }
        char* eq = strchr(p, '=');
        if (!eq) continue;
        *eq = '\0';
        char* key = trim(p), * val = trim(eq + 1);

        if (strcmp(section, "raw_param") == 0) {
            if (strcmp(key, "bit") == 0) cfg->bit = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "used_bit") == 0) cfg->used_bit = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "order") == 0) cfg->order = parse_order(val);
            else if (strcmp(key, "pattern") == 0) cfg->pattern = parse_pattern(val);
        }
        else if (strcmp(section, "module_on") == 0) {
            if (strcmp(key, "ob_on") == 0) cfg->ob_on = (U8)strtoul(val, NULL, 0);
            else if (strcmp(key, "lsc_on") == 0) cfg->lsc_on = (U8)strtoul(val, NULL, 0);
        }
        else if (strcmp(section, "ob") == 0) {
            if (strcmp(key, "ob") == 0) cfg->ob = (U16)(eval_simple_expr(val) + 0.5);
        }
        else if (strcmp(section, "lsc") == 0) {
            if (strcmp(key, "lsc_rgain") == 0) parse_u16_array(val, &cfg->lsc_rgain);
        }
        else if (strcmp(section, "awb") == 0) {
            if (strcmp(key, "r_gain") == 0) cfg->r_gain = (U16)(eval_simple_expr(val) + 0.5);
        }
        else if (strcmp(section, "ccm") == 0) {
            if (strcmp(key, "ccm") == 0) parse_float_array9(val, cfg->ccm);
        }
    }
    fclose(f);
}

// 去除首尾空白
static char* trim(char* s) {
    char* end;
    while (isspace((unsigned char)*s)) s++;
    if (*s == 0) return s;
    end = s + strlen(s) - 1;
    while (end > s && isspace((unsigned char)*end)) end--;
    *(end + 1) = 0;
    return s;
}

// 解析字节顺序
static ByteOrder parse_order(const char* s) {
    return (strcasecmp(s, "BIG_ENDIAN") == 0) ? BIG_ENDIAN : LITTLE_ENDIAN;
}

// 解析 Bayer 格式
static BayerPattern parse_pattern(const char* s) {
    if (strcasecmp(s, "RGGB") == 0) return RGGB;
    else if (strcasecmp(s, "GRBG") == 0) return GRBG;
    else if (strcasecmp(s, "GBRG") == 0) return GBRG;
    else                                   return BGGR;
}

// 计算简单表达式：支持 a 或 a*b
static double eval_simple_expr(const char* s) {
    char* star = (char*)malloc(strlen(s) + 1);
    strcpy(star, s);
    if (!star) {
        return strtod(s, NULL);
    }
    else {
        double a = strtod(s, NULL);
        double b = strtod(star + 1, NULL);
        return a * b;
    }
}

// 解析 U16 数组，返回元素个数
static int parse_u16_array(const char* s, U16** out) {
    // 定位到 '[' 并跳过
    while (*s && *s != '[') s++;
    if (*s == '[') s++;
    size_t cap = 4, cnt = 0;
    U16* arr = (U16*)malloc(cap * sizeof(U16));
    char* copy = strdup(s);
    char* rb = strchr(copy, ']');
    if (rb) *rb = '\0';

    char* tok = strtok(copy, ",");
    while (tok) {
        double v = eval_simple_expr(trim(tok));
        if (cnt >= cap) {
            cap *= 2;
            arr = (U16*)realloc(arr, cap * sizeof(U16));
        }
        arr[cnt++] = (U16)(v + 0.5);
        tok = strtok(NULL, ",");
    }

    free(copy);
    *out = arr;
    return (int)cnt;
}

// 解析 9 元素 float 数组
static void parse_float_array9(const char* s, float out[9]) {
    while (*s && *s != '[') s++;
    if (*s == '[') s++;
    char* copy = strdup(s);
    char* rb = strchr(copy, ']');
    if (rb) *rb = '\0';

    int idx = 0;
    char* tok = strtok(copy, ",");
    while (tok && idx < 9) {
        out[idx++] = (float)eval_simple_expr(trim(tok));
        tok = strtok(NULL, ",");
    }

    free(copy);
}
