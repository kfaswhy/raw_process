#pragma once

#include "load_ini.h"

#define strcasecmp _stricmp 

void load_cfg(G_CONFIG* cfg)
{
	cfg->bit = 16;
	cfg->used_bit = 10;
	cfg->order = LITTLE_ENDIAN;
	cfg->pattern = BGGR;
	cfg->width = 1280;
	cfg->height = 720;

	cfg->rgb_bit = 16;
	cfg->yuv_bit = 16;

	cfg->ob_on = 1;
	cfg->lsc_on = 1;
	cfg->isp_gain_on = 1;
	cfg->awb_on = 1;
	cfg->ltm_on = 0;
	cfg->ccm_on = 1;
	cfg->rgbgamma_on = 1;
	cfg->defog_on = 0;
	//cfg->ygamma_on = 0;
	cfg->sharp_on = 0;
	cfg->ynr_on = 1;
	cfg->cnr_on = 1;
	cfg->yuv_txi_on = 1;

	//12->16bit
	cfg->ob = 64 * 16;


    cfg->lsc_type = 0; //0为插值
    cfg->lsc_wblock = 17;
    cfg->lsc_hblock = 17;
#if 1
    U16 lsc_tmpr[] = {
        1024 ,1024 ,1024 ,1024 ,1047 ,1048 ,1119 ,1103 ,1152 ,1170 ,1163 ,1214 ,1180 ,1225 ,1257 ,1274 ,1351 ,
1024 ,1024 ,1024 ,1043 ,1030 ,1024 ,1073 ,1120 ,1127 ,1180 ,1220 ,1248 ,1221 ,1254 ,1274 ,1237 ,1368 ,
1024 ,1031 ,1024 ,1024 ,1047 ,1070 ,1141 ,1149 ,1204 ,1253 ,1243 ,1236 ,1256 ,1287 ,1319 ,1388 ,1341 ,
1024 ,1040 ,1024 ,1024 ,1056 ,1053 ,1139 ,1216 ,1259 ,1347 ,1301 ,1370 ,1378 ,1347 ,1336 ,1346 ,1362 ,
1040 ,1024 ,1024 ,1024 ,1032 ,1087 ,1155 ,1259 ,1307 ,1345 ,1382 ,1364 ,1397 ,1383 ,1335 ,1338 ,1374 ,
1024 ,1024 ,1024 ,1024 ,1057 ,1111 ,1234 ,1314 ,1372 ,1419 ,1456 ,1508 ,1442 ,1447 ,1364 ,1373 ,1398 ,
1028 ,1024 ,1024 ,1024 ,1055 ,1142 ,1275 ,1343 ,1358 ,1474 ,1483 ,1497 ,1448 ,1457 ,1399 ,1383 ,1348 ,
1024 ,1024 ,1024 ,1024 ,1089 ,1156 ,1268 ,1330 ,1439 ,1545 ,1538 ,1522 ,1478 ,1468 ,1402 ,1414 ,1350 ,
1059 ,1024 ,1024 ,1036 ,1076 ,1155 ,1282 ,1412 ,1419 ,1460 ,1523 ,1513 ,1489 ,1434 ,1429 ,1410 ,1353 ,
1024 ,1027 ,1024 ,1024 ,1095 ,1155 ,1245 ,1396 ,1429 ,1475 ,1476 ,1516 ,1474 ,1405 ,1387 ,1349 ,1354 ,
1024 ,1024 ,1024 ,1025 ,1095 ,1151 ,1266 ,1327 ,1393 ,1462 ,1495 ,1516 ,1470 ,1454 ,1423 ,1359 ,1295 ,
1024 ,1024 ,1024 ,1028 ,1078 ,1145 ,1237 ,1338 ,1366 ,1419 ,1454 ,1451 ,1419 ,1399 ,1343 ,1314 ,1319 ,
1024 ,1024 ,1024 ,1024 ,1073 ,1145 ,1220 ,1251 ,1323 ,1353 ,1387 ,1370 ,1365 ,1388 ,1330 ,1381 ,1268 ,
1024 ,1024 ,1024 ,1029 ,1053 ,1109 ,1158 ,1231 ,1263 ,1321 ,1326 ,1321 ,1331 ,1311 ,1277 ,1310 ,1300 ,
1024 ,1024 ,1031 ,1024 ,1024 ,1083 ,1110 ,1184 ,1227 ,1225 ,1238 ,1258 ,1279 ,1296 ,1251 ,1284 ,1264 ,
1024 ,1024 ,1024 ,1051 ,1028 ,1056 ,1098 ,1125 ,1162 ,1157 ,1172 ,1214 ,1203 ,1247 ,1220 ,1266 ,1280 ,
1024 ,1024 ,1101 ,1028 ,1031 ,1071 ,1024 ,1081 ,1072 ,1108 ,1157 ,1170 ,1186 ,1172 ,1199 ,1267 ,1319
    };
    U16 lsc_tmpgr[] = {
        1183 ,1183 ,1205 ,1124 ,1158 ,1058 ,1108 ,1096 ,1088 ,1045 ,1075 ,1080 ,1108 ,1089 ,1082 ,1094 ,1090 ,
1265 ,1189 ,1185 ,1152 ,1109 ,1083 ,1069 ,1047 ,1066 ,1063 ,1071 ,1043 ,1068 ,1076 ,1072 ,1073 ,1079 ,
1195 ,1158 ,1171 ,1172 ,1099 ,1099 ,1083 ,1059 ,1071 ,1031 ,1058 ,1040 ,1065 ,1071 ,1090 ,1125 ,1087 ,
1218 ,1228 ,1226 ,1185 ,1146 ,1106 ,1077 ,1064 ,1092 ,1085 ,1057 ,1077 ,1098 ,1099 ,1120 ,1126 ,1112 ,
1204 ,1233 ,1226 ,1229 ,1139 ,1119 ,1088 ,1100 ,1077 ,1061 ,1085 ,1070 ,1092 ,1097 ,1114 ,1095 ,1142 ,
1279 ,1211 ,1272 ,1181 ,1151 ,1139 ,1126 ,1116 ,1096 ,1084 ,1084 ,1097 ,1098 ,1133 ,1128 ,1143 ,1149 ,
1255 ,1263 ,1278 ,1204 ,1152 ,1140 ,1123 ,1093 ,1085 ,1082 ,1071 ,1101 ,1097 ,1105 ,1109 ,1144 ,1161 ,
1293 ,1271 ,1265 ,1188 ,1158 ,1152 ,1115 ,1102 ,1106 ,1101 ,1091 ,1102 ,1120 ,1145 ,1149 ,1139 ,1169 ,
1242 ,1287 ,1251 ,1175 ,1178 ,1132 ,1116 ,1097 ,1086 ,1095 ,1078 ,1099 ,1111 ,1116 ,1156 ,1153 ,1163 ,
1237 ,1240 ,1244 ,1216 ,1162 ,1140 ,1114 ,1110 ,1106 ,1108 ,1109 ,1094 ,1089 ,1115 ,1114 ,1164 ,1165 ,
1245 ,1252 ,1239 ,1193 ,1188 ,1134 ,1114 ,1097 ,1098 ,1101 ,1117 ,1092 ,1094 ,1130 ,1144 ,1163 ,1143 ,
1260 ,1206 ,1209 ,1169 ,1141 ,1143 ,1095 ,1091 ,1078 ,1066 ,1077 ,1077 ,1085 ,1077 ,1098 ,1159 ,1149 ,
1279 ,1219 ,1213 ,1184 ,1146 ,1129 ,1110 ,1083 ,1072 ,1081 ,1086 ,1076 ,1093 ,1096 ,1098 ,1138 ,1113 ,
1284 ,1230 ,1226 ,1162 ,1130 ,1113 ,1094 ,1067 ,1075 ,1050 ,1073 ,1062 ,1086 ,1057 ,1095 ,1097 ,1131 ,
1302 ,1184 ,1145 ,1140 ,1127 ,1091 ,1056 ,1066 ,1048 ,1024 ,1043 ,1047 ,1052 ,1072 ,1092 ,1115 ,1090 ,
1327 ,1219 ,1151 ,1134 ,1106 ,1076 ,1066 ,1045 ,1034 ,1024 ,1041 ,1048 ,1049 ,1063 ,1051 ,1080 ,1094 ,
1202 ,1183 ,1129 ,1090 ,1071 ,1047 ,1024 ,1036 ,1024 ,1024 ,1024 ,1030 ,1043 ,1036 ,1052 ,1070 ,1087
    };
    U16 lsc_tmpgb[] = {
        1031 ,1031 ,1077 ,1025 ,1072 ,1024 ,1093 ,1062 ,1083 ,1053 ,1053 ,1094 ,1057 ,1042 ,1024 ,1024 ,1064 ,
1101 ,1030 ,1083 ,1024 ,1024 ,1036 ,1034 ,1033 ,1055 ,1058 ,1049 ,1024 ,1024 ,1033 ,1042 ,1024 ,1024 ,
1028 ,1024 ,1026 ,1031 ,1026 ,1042 ,1024 ,1024 ,1037 ,1032 ,1036 ,1024 ,1024 ,1046 ,1024 ,1024 ,1024 ,
1047 ,1024 ,1078 ,1044 ,1041 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1024 ,1046 ,1067 ,1077 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1081 ,1054 ,1091 ,1033 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1024 ,1053 ,1047 ,1036 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1072 ,1077 ,1080 ,1028 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1024 ,1060 ,1047 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1028 ,1024 ,1047 ,1035 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1049 ,1050 ,1068 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1056 ,1028 ,1040 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1085 ,1025 ,1037 ,1042 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1099 ,1049 ,1057 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1161 ,1043 ,1024 ,1036 ,1033 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1176 ,1074 ,1029 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1029 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,
1066 ,1047 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1032 ,1062 ,1024 ,1024 ,1024 ,1024 ,1024 ,1036
    };
    U16 lsc_tmpb[] = {
        1052 ,1052 ,1066 ,1058 ,1024 ,1026 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1024 ,1027 ,1043 ,1024 ,
1144 ,1082 ,1077 ,1044 ,1048 ,1034 ,1024 ,1024 ,1024 ,1024 ,1024 ,1032 ,1032 ,1024 ,1024 ,1047 ,1036 ,
1063 ,1028 ,1059 ,1050 ,1024 ,1024 ,1060 ,1025 ,1024 ,1024 ,1024 ,1030 ,1051 ,1024 ,1049 ,1055 ,1044 ,
1069 ,1075 ,1104 ,1051 ,1024 ,1043 ,1028 ,1054 ,1063 ,1069 ,1033 ,1038 ,1058 ,1073 ,1048 ,1075 ,1046 ,
1051 ,1076 ,1085 ,1104 ,1045 ,1052 ,1026 ,1072 ,1061 ,1058 ,1081 ,1063 ,1042 ,1057 ,1060 ,1073 ,1057 ,
1097 ,1065 ,1118 ,1045 ,1052 ,1052 ,1082 ,1077 ,1089 ,1084 ,1082 ,1082 ,1074 ,1083 ,1088 ,1065 ,1058 ,
1083 ,1088 ,1098 ,1086 ,1036 ,1050 ,1085 ,1077 ,1091 ,1080 ,1058 ,1096 ,1093 ,1075 ,1058 ,1080 ,1062 ,
1104 ,1121 ,1120 ,1055 ,1060 ,1062 ,1096 ,1110 ,1102 ,1115 ,1099 ,1100 ,1074 ,1092 ,1085 ,1094 ,1076 ,
1102 ,1128 ,1106 ,1059 ,1076 ,1069 ,1071 ,1083 ,1096 ,1091 ,1109 ,1088 ,1073 ,1083 ,1103 ,1086 ,1116 ,
1086 ,1073 ,1082 ,1082 ,1070 ,1062 ,1060 ,1080 ,1089 ,1099 ,1095 ,1091 ,1092 ,1083 ,1069 ,1058 ,1071 ,
1110 ,1095 ,1091 ,1069 ,1081 ,1074 ,1079 ,1092 ,1086 ,1090 ,1099 ,1092 ,1091 ,1099 ,1104 ,1078 ,1057 ,
1116 ,1081 ,1094 ,1085 ,1067 ,1084 ,1092 ,1102 ,1088 ,1087 ,1112 ,1108 ,1094 ,1068 ,1059 ,1098 ,1049 ,
1131 ,1068 ,1085 ,1086 ,1077 ,1068 ,1086 ,1063 ,1071 ,1074 ,1079 ,1063 ,1080 ,1062 ,1057 ,1099 ,1043 ,
1147 ,1092 ,1099 ,1068 ,1050 ,1043 ,1064 ,1058 ,1069 ,1064 ,1088 ,1049 ,1057 ,1035 ,1067 ,1045 ,1049 ,
1197 ,1091 ,1050 ,1060 ,1065 ,1062 ,1053 ,1057 ,1054 ,1034 ,1060 ,1045 ,1039 ,1056 ,1064 ,1060 ,1042 ,
1222 ,1111 ,1053 ,1081 ,1048 ,1030 ,1042 ,1049 ,1043 ,1030 ,1025 ,1044 ,1044 ,1049 ,1041 ,1058 ,1054 ,
1108 ,1108 ,1082 ,1045 ,1034 ,1035 ,1024 ,1039 ,1035 ,1041 ,1034 ,1035 ,1052 ,1038 ,1039 ,1037 ,1024
    };
#endif

    cfg->isp_gain = 1024 * 1.5;
    cfg->isp_gain = 1024 * 1.5;

	cfg->r_gain = 1024 * 1.95;
	cfg->g_gain = 1024 * 1;
	cfg->b_gain = 1024 * 1.13;


	cfg->ltm_r = 20;
	cfg->ltm_str = 1.3;
	cfg->ltm_gain_limit_max = 2;
	cfg->ltm_gain_limit_min = 0.0;


	float ccm_tmp[9] = {
	1.11, -0.11, -0.01,
	-0.16, 1.43, -0.28,
	0.05, -0.32, 1.30



	};

	U32 gamma_xtmp[GAMMA_LENGTH] =
	{
	0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,256,320,384,448,512,640,768,896,1024,1280,1536,1792,2048,2304,2560,2816,3072,3328,3584,3840,4095
	};

	U32 gamma_ytmp[GAMMA_LENGTH] =
	{
	0,6,11,17,22,28,33,39,44,55,66,77,88,109,130,150,170,210,248,286,323,393,460,525,586,702,809,909,1002,1172,1323,1461,1587,1810,2003,2173,2325,2589,2812,3010,3191,3355,3499,3624,3736,3836,3927,4012,4095
	};

	cfg->ynr_r = 1;
	cfg->cnr_r = 3;

	cfg->txi_r_detail = 1;
	cfg->txi_r_bifilter = 1;
	cfg->txi_str = 5;

	//以下后处理
	U16 lsc_blk = cfg->lsc_wblock * cfg->lsc_hblock;
	cfg->lsc_rgain = (U16*)malloc(sizeof(U16) * lsc_blk);
	cfg->lsc_bgain = (U16*)malloc(sizeof(U16) * lsc_blk);
	cfg->lsc_grgain = (U16*)malloc(sizeof(U16) * lsc_blk);
	cfg->lsc_gbgain = (U16*)malloc(sizeof(U16) * lsc_blk);

	memcpy(cfg->lsc_rgain, lsc_tmpr, sizeof(U16) * lsc_blk);
	memcpy(cfg->lsc_bgain, lsc_tmpb, sizeof(U16) * lsc_blk);
	memcpy(cfg->lsc_grgain, lsc_tmpgr, sizeof(U16) * lsc_blk);
	memcpy(cfg->lsc_gbgain, lsc_tmpgb, sizeof(U16) * lsc_blk);


	memcpy(cfg->ccm, ccm_tmp, 9 * sizeof(float));
	if (cfg->rgb_bit > 12)
	{
		U8 shift = cfg->rgb_bit - 12;
		for (int i = 0; i < GAMMA_LENGTH; i++)
		{
			cfg->gamma_x[i] = gamma_xtmp[i] << shift;
			cfg->gamma_y[i] = gamma_ytmp[i] << shift;
		}
	}
	else if (cfg->rgb_bit < 12)
	{
		U8 shift = 12 - cfg->rgb_bit;
		for (int i = 0; i < GAMMA_LENGTH; i++)
		{
			cfg->gamma_x[i] = gamma_xtmp[i] >> shift;
			cfg->gamma_y[i] = gamma_ytmp[i] >> shift;
		}
	}

	return;
}

// 从 INI 文件加载配置
void load_cfg_from_ini(const char* filename, G_CONFIG* cfg) {
	FILE* f = fopen(filename, "r");
	if (!f) {
		perror("fopen");
		return;
	}
	// 初始化默认值
	memset(cfg, 0, sizeof(*cfg));
	cfg->order = LITTLE_ENDIAN;
	cfg->pattern = BGGR;
	cfg->lsc_rgain = NULL;

	char line[256], section[64] = { 0 };
	while (fgets(line, sizeof(line), f)) {
		char* p = trim(line);
		if (*p == 0 || *p == ';') continue;
		if (*p == '[') {
			char* end = strchr(p, ']');
			if (end) {
				size_t len = end - p - 1;
				strncpy(section, p + 1, len);
				section[len] = '\0';
			}
			continue;
		}
		char* eq = strchr(p, '=');
		if (!eq) continue;
		*eq = '\0';
		char* key = trim(p), * val = trim(eq + 1);

		if (strcmp(section, "raw_param") == 0) {
			if (strcmp(key, "bit") == 0) cfg->bit = (U8)strtoul(val, NULL, 0);
			else if (strcmp(key, "used_bit") == 0) cfg->used_bit = (U8)strtoul(val, NULL, 0);
			else if (strcmp(key, "order") == 0) cfg->order = parse_order(val);
			else if (strcmp(key, "pattern") == 0) cfg->pattern = parse_pattern(val);
		}
		else if (strcmp(section, "module_on") == 0) {
			if (strcmp(key, "ob_on") == 0) cfg->ob_on = (U8)strtoul(val, NULL, 0);
			else if (strcmp(key, "lsc_on") == 0) cfg->lsc_on = (U8)strtoul(val, NULL, 0);
		}
		else if (strcmp(section, "ob") == 0) {
			if (strcmp(key, "ob") == 0) cfg->ob = (U16)(eval_simple_expr(val) + 0.5);
		}
		else if (strcmp(section, "lsc") == 0) {
			if (strcmp(key, "lsc_rgain") == 0) parse_u16_array(val, &cfg->lsc_rgain);
		}
		else if (strcmp(section, "awb") == 0) {
			if (strcmp(key, "r_gain") == 0) cfg->r_gain = (U16)(eval_simple_expr(val) + 0.5);
		}
		else if (strcmp(section, "ccm") == 0) {
			if (strcmp(key, "ccm") == 0) parse_float_array9(val, cfg->ccm);
		}
	}
	fclose(f);
}

// 去除首尾空白
static char* trim(char* s) {
	char* end;
	while (isspace((unsigned char)*s)) s++;
	if (*s == 0) return s;
	end = s + strlen(s) - 1;
	while (end > s && isspace((unsigned char)*end)) end--;
	*(end + 1) = 0;
	return s;
}

// 解析字节顺序
static ByteOrder parse_order(const char* s) {
	return (strcasecmp(s, "BIG_ENDIAN") == 0) ? BIG_ENDIAN : LITTLE_ENDIAN;
}

// 解析 Bayer 格式
static BayerPattern parse_pattern(const char* s) {
	if (strcasecmp(s, "RGGB") == 0) return RGGB;
	else if (strcasecmp(s, "GRBG") == 0) return GRBG;
	else if (strcasecmp(s, "GBRG") == 0) return GBRG;
	else   return BGGR;
}

// 计算简单表达式：支持 a 或 a*b
static double eval_simple_expr(const char* s) {
	char* star = (char*)malloc(strlen(s) + 1);
	strcpy(star, s);
	if (!star) {
		return strtod(s, NULL);
	}
	else {
		double a = strtod(s, NULL);
		double b = strtod(star + 1, NULL);
		return a * b;
	}
}

// 解析 U16 数组，返回元素个数
static int parse_u16_array(const char* s, U16** out) {
	// 定位到 '[' 并跳过
	while (*s && *s != '[') s++;
	if (*s == '[') s++;
	size_t cap = 4, cnt = 0;
	U16* arr = (U16*)malloc(cap * sizeof(U16));
	char* copy = strdup(s);
	char* rb = strchr(copy, ']');
	if (rb) *rb = '\0';

	char* tok = strtok(copy, ",");
	while (tok) {
		double v = eval_simple_expr(trim(tok));
		if (cnt >= cap) {
			cap *= 2;
			arr = (U16*)realloc(arr, cap * sizeof(U16));
		}
		arr[cnt++] = (U16)(v + 0.5);
		tok = strtok(NULL, ",");
	}

	free(copy);
	*out = arr;
	return (int)cnt;
}

// 解析 9 元素 float 数组
static void parse_float_array9(const char* s, float out[9]) {
	while (*s && *s != '[') s++;
	if (*s == '[') s++;
	char* copy = strdup(s);
	char* rb = strchr(copy, ']');
	if (rb) *rb = '\0';

	int idx = 0;
	char* tok = strtok(copy, ",");
	while (tok && idx < 9) {
		out[idx++] = (float)eval_simple_expr(trim(tok));
		tok = strtok(NULL, ",");
	}

	free(copy);
}
